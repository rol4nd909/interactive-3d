// Initial-generated by: https://github.com/pmndrs/gltfjsx

import * as THREE from "three";
import { useGLTF, useTexture } from "@react-three/drei";
import { GLTF } from "three-stdlib";
import { useCallback, useEffect, useMemo, useRef } from "react";
import { useFrame } from "@react-three/fiber";
import gsap from "gsap";
import { ColorSpace } from "three";

// ---- Types ----
type SkateboardProps = {
  gripTapeColor: string;
  boltColor: string;
  basePlateColor?: string;
  truckColor: string;
  deckTextureURLs: string[];
  wheelTextureURLs: string[];
  activeDeckIndex?: number;
  activeWheelIndex?: number;
  constantWheelSpin?: boolean;
  pose?: "upright" | "side";
};

type GLTFResult = GLTF & {
  nodes: {
    GripTape: THREE.Mesh;
    Wheel1: THREE.Mesh;
    Wheel2: THREE.Mesh;
    Deck: THREE.Mesh;
    Wheel4: THREE.Mesh;
    Bolts: THREE.Mesh;
    Wheel3: THREE.Mesh;
    Baseplates: THREE.Mesh;
    Truck1: THREE.Mesh;
    Truck2: THREE.Mesh;
  };
};

// ---- Utility ----
function useSkateboardGLTF(): GLTFResult {
  return useGLTF(
    `${import.meta.env.BASE_URL}skateboard.gltf`
  ) as unknown as GLTFResult;
}

function configureTexture(
  texture: THREE.Texture,
  options?: {
    colorSpace?: ColorSpace;
    repeat?: [number, number];
    anisotropy?: number;
  }
) {
  texture.flipY = false;

  if (options?.colorSpace) {
    texture.colorSpace = options.colorSpace;
  }

  if (options?.repeat) {
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;
    texture.repeat.set(...options.repeat);
  }

  if (options?.anisotropy) {
    texture.anisotropy = options.anisotropy;
  }
}

/**
 * Skateboard
 *
 * A 3D skateboard component rendered with Three.js and React Three Fiber.
 *
 * Features:
 * - Customizable materials: grip tape, bolts, trucks, baseplate, deck, and wheels
 * - Two poses: 'upright' (default) or 'side' (resting on its side)
 * - Wheel animation with optional continuous spin or GSAP-based slowdown
 * - Texture and model loading via @react-three/drei (useGLTF, useTexture)
 *
 * Usage:
 * Place inside a <Canvas> from @react-three/fiber to render in a Three.js scene.
 * Ideal for product configurators, visual demos, or immersive UI elements.
 *
 * Assets:
 * - GLTF model: /public/skateboard.gltf
 * - Textures: deck variations, wheel variations, grip tape, metal normal map
 *
 * Notes:
 * - Internally uses `useFrame` for animation and `gsap` for smooth transitions
 * - Preloads the GLTF model for better runtime performance
 */
export function Skateboard({
  gripTapeColor,
  boltColor,
  basePlateColor,
  truckColor,
  deckTextureURLs,
  wheelTextureURLs,
  activeDeckIndex,
  activeWheelIndex,
  constantWheelSpin = false,
  pose = "upright",
}: SkateboardProps) {
  const wheelRefs = useRef<THREE.Object3D[]>([]);
  const { nodes } = useSkateboardGLTF();

  // Add Wheel Refs
  const addToWheelRefs = useCallback((ref: THREE.Object3D | null) => {
    if (ref && !wheelRefs.current.includes(ref)) {
      wheelRefs.current.push(ref);
    }
  }, []);

  // Load and prepare textures
  const deckTextures = useTexture(deckTextureURLs);
  const wheelTextures = useTexture(wheelTextureURLs);
  deckTextures.forEach((texture) =>
    configureTexture(texture, { colorSpace: "srgb" })
  );
  wheelTextures.forEach((texture) =>
    configureTexture(texture, { colorSpace: "srgb" })
  );

  const deckTexture = deckTextures[activeDeckIndex || 0];
  const wheelTexture = wheelTextures[activeWheelIndex || 0];

  const gripTapeDiffuse = useTexture(
    `${import.meta.env.BASE_URL}skateboard/griptape-diffuse.webp`
  );
  const gripTapeRoughness = useTexture(
    `${import.meta.env.BASE_URL}skateboard/griptape-roughness.webp`
  );
  const metalNormal = useTexture(
    `${import.meta.env.BASE_URL}skateboard/metal-normal.avif`
  );

  configureTexture(metalNormal, { repeat: [8, 8], anisotropy: 8 });

  // Materials
  const gripTapeMaterial = useMemo(() => {
    if (gripTapeDiffuse) {
      configureTexture(gripTapeDiffuse, { repeat: [9, 9] });
      configureTexture(gripTapeRoughness, { repeat: [9, 9], anisotropy: 8 });
    }

    return new THREE.MeshStandardMaterial({
      map: gripTapeDiffuse,
      bumpMap: gripTapeRoughness,
      roughnessMap: gripTapeRoughness,
      bumpScale: 3.5,
      roughness: 0.8,
      color: gripTapeColor,
    });
  }, [gripTapeColor, gripTapeDiffuse, gripTapeRoughness]);

  const boltMaterial = useMemo(
    () =>
      new THREE.MeshStandardMaterial({
        color: boltColor,
        roughness: 0.35,
        metalness: 0.65,
      }),
    [boltColor]
  );

  const basePlateMaterial = useMemo(
    () =>
      new THREE.MeshStandardMaterial({
        color: basePlateColor || truckColor,
        normalMap: metalNormal,
        normalScale: new THREE.Vector2(0.2, 0.2),
        roughness: 0.2,
        metalness: 0.6,
      }),
    [basePlateColor, truckColor, metalNormal]
  );

  const truckMaterial = useMemo(
    () =>
      new THREE.MeshStandardMaterial({
        color: truckColor,
        normalMap: metalNormal,
        normalScale: new THREE.Vector2(0.25, 0.25),
        roughness: 0.25,
        metalness: 0.6,
      }),
    [truckColor, metalNormal]
  );

  const deckMaterial = useMemo(
    () =>
      new THREE.MeshStandardMaterial({
        map: deckTexture,
        roughness: 0.1,
      }),
    [deckTexture]
  );

  const wheelMaterial = useMemo(
    () =>
      new THREE.MeshStandardMaterial({
        map: wheelTexture,
        roughness: 0.35,
      }),
    [wheelTexture]
  );

  // Constant Wheel Spin
  useFrame(() => {
    if (!wheelRefs.current || !constantWheelSpin) return;

    for (const wheel of wheelRefs.current) {
      wheel.rotation.x += 0.2;
    }
  });

  // Slowdown wheel spin
  useEffect(() => {
    if (!wheelRefs.current || constantWheelSpin) return;

    for (const wheel of wheelRefs.current) {
      // GSAP animation to slow down the wheel spin
      gsap.to(wheel.rotation, {
        x: "+=30",
        duration: 2.5,
        ease: "circ.out",
      });
    }
  }, [constantWheelSpin, activeWheelIndex]);

  const positions = useMemo(
    () =>
      ({
        upright: {
          rotation: [0, 0, 0],
          position: [0, 0, 0],
        },
        side: {
          rotation: [0, 0, Math.PI / 2],
          position: [0, 0.295, 0],
        },
      } as const),
    []
  );

  return (
    <group
      dispose={null}
      rotation={positions[pose].rotation}
      position={positions[pose].position}
    >
      <group name="Scene">
        <mesh
          name="GripTape"
          castShadow
          receiveShadow
          geometry={nodes.GripTape.geometry}
          material={gripTapeMaterial}
          position={[0, 0.286, -0.002]}
        />
        <mesh
          name="Bolts"
          castShadow
          receiveShadow
          geometry={nodes.Bolts.geometry}
          material={boltMaterial}
          position={[0, 0.198, 0]}
          rotation={[Math.PI, 0, Math.PI]}
        />
        <mesh
          name="Wheel1"
          castShadow
          receiveShadow
          geometry={nodes.Wheel1.geometry}
          material={wheelMaterial}
          position={[0.238, 0.086, 0.635]}
          ref={addToWheelRefs}
        />
        <mesh
          name="Wheel2"
          castShadow
          receiveShadow
          geometry={nodes.Wheel2.geometry}
          material={wheelMaterial}
          position={[-0.237, 0.086, 0.635]}
          ref={addToWheelRefs}
        />
        <mesh
          name="Wheel3"
          castShadow
          receiveShadow
          geometry={nodes.Wheel3.geometry}
          material={wheelMaterial}
          position={[0.237, 0.086, -0.635]}
          rotation={[Math.PI, 0, Math.PI]}
          ref={addToWheelRefs}
        />
        <mesh
          name="Wheel4"
          castShadow
          receiveShadow
          geometry={nodes.Wheel4.geometry}
          material={wheelMaterial}
          position={[-0.238, 0.086, -0.635]}
          rotation={[Math.PI, 0, Math.PI]}
          ref={addToWheelRefs}
        />
        <mesh
          name="Deck"
          castShadow
          receiveShadow
          geometry={nodes.Deck.geometry}
          material={deckMaterial}
          position={[0, 0.271, -0.002]}
        />
        <mesh
          name="Baseplates"
          castShadow
          receiveShadow
          geometry={nodes.Baseplates.geometry}
          material={basePlateMaterial}
          position={[0, 0.211, 0]}
        />
        <mesh
          name="Truck1"
          castShadow
          receiveShadow
          geometry={nodes.Truck1.geometry}
          material={truckMaterial}
          position={[0, 0.101, -0.617]}
        />
        <mesh
          name="Truck2"
          castShadow
          receiveShadow
          geometry={nodes.Truck2.geometry}
          material={truckMaterial}
          position={[0, 0.101, 0.617]}
          rotation={[Math.PI, 0, Math.PI]}
        />
      </group>
    </group>
  );
}

useGLTF.preload(`${import.meta.env.BASE_URL}skateboard.gltf`);
